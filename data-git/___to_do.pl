hasSourceFile('../to.do').
hasLastParsedTimeStamp('../to.do',[['-',['-',2022,08],11],[':',[':',08,41],52]]).

'now we want to go ahead and work on figuring out which of the four cases entries pertain to:'().
.
'question, what happens when it reverts to a previous update? i.e.'('_SINGLEQUOTE_hi_SINGLEQUOTE_,a','_SINGLEQUOTE_ho_SINGLEQUOTE_,b','_SINGLEQUOTE_hi_SINGLEQUOTE_,c','.').
'what does the b in'('a,b','correspond to if we don_SINGLEQUOTE_t have revisions? would it be last modified times?').
'what happens if we move or delete a file, or something to do with symlinks or hardlinks?'().
'what happens if we move an entry between files?'().
'what about recurrent things like _SINGLEQUOTE_take out the trash_SINGLEQUOTE_?'().
'how should we save files?'().
'should we save the first parse, and then incremental changes? i.e.'().
'should we save them all in a git repo, and just checkout the various revisions as needed?'().
'how does this mesh with qlf?'().
'what about using persistency: https://www.swi-prolog.org/pldoc/doc/_swi_/library/persistency.pl'().
'or mysql?: https://github.com/aindilis/data-integration'().
'where do we store the updatedirectly'('and depends/2','facts?').
'how to mark an entry deleted? do we say:'(sarray('a,b'),or,sarray('false,b1','a,b'),'?').
'we should have predicates that take'(sarray('1djslfkjdlfjlkdkfldf','3urgjlgkdjglgdlgkf'),'. ->','_SINGLEQUOTE_take out the trash and recyclables and returnables_SINGLEQUOTE_,_SINGLEQUOTE_gather the trash_SINGLEQUOTE_','.').
